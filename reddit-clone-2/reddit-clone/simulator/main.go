// simulator/main.go
// simulator/main.go
package main

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"reddit-clone/client/reddit"
	"sync"
	"time"
)

type Simulator struct {
	clients    []*reddit.Client
	usernames  []string
	subreddits []string
	metrics    *Metrics
	wg         sync.WaitGroup
}

type Metrics struct {
	mu                sync.Mutex
	postsCreated      int
	commentsCreated   int
	votesCreated      int
	messagesExchanged int
	responseLatencies []time.Duration
}

func NewSimulator(numUsers int, baseURL string) *Simulator {
	log.Printf("Initializing simulator with %d users at %s", numUsers, baseURL)

	sim := &Simulator{
		clients:    make([]*reddit.Client, numUsers),
		usernames:  make([]string, numUsers),
		subreddits: []string{"news", "tech", "gaming", "movies", "music"},
		metrics:    &Metrics{},
	}

	// Initialize clients and create users
	for i := 0; i < numUsers; i++ {
		client := reddit.NewClient(baseURL)
		username := fmt.Sprintf("user%d", i)
		password := fmt.Sprintf("pass%d", i)

		log.Printf("Registering user: %s", username)
		if err := client.Register(username, password); err != nil {
			log.Printf("Failed to register user %s: %v", username, err)
			continue
		}

		log.Printf("Logging in user: %s", username)
		if err := client.Login(username, password); err != nil {
			log.Printf("Failed to login user %s: %v", username, err)
			continue
		}

		sim.clients[i] = client
		sim.usernames[i] = username
		log.Printf("Successfully initialized user: %s", username)
	}

	return sim
}

func (s *Simulator) Run(ctx context.Context, duration time.Duration) {
	log.Printf("Starting simulation for duration: %v", duration)
	deadline := time.Now().Add(duration)

	// Simulate Zipf distribution for subreddit subscriptions
	zipf := rand.NewZipf(rand.New(rand.NewSource(time.Now().UnixNano())), 1.5, 1, uint64(len(s.subreddits)))

	// Subscribe users to subreddits based on Zipf distribution
	log.Println("Setting up subreddit subscriptions...")
	for i, client := range s.clients {
		numSubs := int(zipf.Uint64()) + 1
		for j := 0; j < numSubs && j < len(s.subreddits); j++ {
			log.Printf("User %s joining subreddit: %s", s.usernames[i], s.subreddits[j])
			if err := client.JoinSubreddit(ctx, s.subreddits[j]); err != nil {
				log.Printf("User %s failed to join subreddit %s: %v", s.usernames[i], s.subreddits[j], err)
			}
		}
	}

	log.Println("Starting user simulation routines...")
	// Start simulating user activities
	for i := range s.clients {
		s.wg.Add(1)
		go s.simulateUser(ctx, i, deadline)
	}

	// Print periodic updates
	ticker := time.NewTicker(30 * time.Second)
	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				s.printCurrentMetrics()
			}
		}
	}()

	log.Println("Waiting for simulation to complete...")
	s.wg.Wait()
	ticker.Stop()

	log.Println("Simulation completed. Final metrics:")
	s.printMetrics()
}

func (s *Simulator) printCurrentMetrics() {
	s.metrics.mu.Lock()
	defer s.metrics.mu.Unlock()

	log.Printf("Current metrics - Posts: %d, Comments: %d, Votes: %d, Messages: %d",
		s.metrics.postsCreated,
		s.metrics.commentsCreated,
		s.metrics.votesCreated,
		s.metrics.messagesExchanged)
}

func (s *Simulator) simulateUser(ctx context.Context, userIndex int, deadline time.Time) {
	defer s.wg.Done()

	client := s.clients[userIndex]
	username := s.usernames[userIndex]

	// Simulate connection/disconnection periods
	connected := true
	connectionToggleTicker := time.NewTicker(time.Duration(rand.Intn(300)+300) * time.Second)
	defer connectionToggleTicker.Stop()

	activityTicker := time.NewTicker(time.Duration(rand.Intn(30)+30) * time.Second)
	defer activityTicker.Stop()

	for time.Now().Before(deadline) {
		select {
		case <-ctx.Done():
			return
		case <-connectionToggleTicker.C:
			connected = !connected
			if connected {
				if err := client.ConnectWebSocket(username); err != nil {
					log.Printf("Failed to connect WebSocket for user %s: %v", username, err)
				}
			}
		case <-activityTicker.C:
			if !connected {
				continue
			}

			// Perform random activity
			switch rand.Intn(5) {
			case 0:
				s.simulateCreatePost(ctx, client, username)
			case 1:
				s.simulateCreateComment(ctx, client, username)
			case 2:
				s.simulateVote(ctx, client, username)
			case 3:
				s.simulateMessage(ctx, client, username)
			case 4:
				s.simulateReadFeed(ctx, client)
			}
		}
	}
}

func (s *Simulator) simulateCreatePost(ctx context.Context, client *reddit.Client, username string) {
	start := time.Now()
	subreddit := s.subreddits[rand.Intn(len(s.subreddits))]
	title := fmt.Sprintf("Post by %s at %v", username, time.Now())
	content := fmt.Sprintf("Content generated by simulator at %v", time.Now())

	_, err := client.CreatePost(ctx, title, content, subreddit) // Remove unused post variable
	if err != nil {
		log.Printf("Failed to create post: %v", err)
		return
	}

	s.metrics.mu.Lock()
	s.metrics.postsCreated++
	s.metrics.responseLatencies = append(s.metrics.responseLatencies, time.Since(start))
	s.metrics.mu.Unlock()
}

func (s *Simulator) simulateCreateComment(ctx context.Context, client *reddit.Client, username string) {
	// Simulate commenting on a random post
	feed, err := client.GetFeed(ctx, 0, 10)
	if err != nil || len(feed.Posts) == 0 {
		return
	}

	post := feed.Posts[rand.Intn(len(feed.Posts))]
	content := fmt.Sprintf("Comment by %s at %v", username, time.Now())

	if _, err := client.CreateComment(ctx, post.ID, content, nil); err != nil {
		log.Printf("Failed to create comment: %v", err)
		return
	}

	s.metrics.mu.Lock()
	s.metrics.commentsCreated++
	s.metrics.mu.Unlock()
}

func (s *Simulator) simulateVote(ctx context.Context, client *reddit.Client, username string) {
	feed, err := client.GetFeed(ctx, 0, 10)
	if err != nil || len(feed.Posts) == 0 {
		return
	}

	post := feed.Posts[rand.Intn(len(feed.Posts))]
	isUpvote := rand.Float32() > 0.3 // 70% chance of upvote

	if err := client.Vote(ctx, post.ID, isUpvote, "post"); err != nil {
		log.Printf("Failed to vote: %v", err)
		return
	}

	s.metrics.mu.Lock()
	s.metrics.votesCreated++
	s.metrics.mu.Unlock()
}

func (s *Simulator) simulateMessage(ctx context.Context, client *reddit.Client, username string) {
	// Send message to random user
	randomUserIndex := rand.Intn(len(s.usernames))
	toUser := s.usernames[randomUserIndex]

	if toUser == username {
		return // Don't send message to self
	}

	content := fmt.Sprintf("Message from %s at %v", username, time.Now())
	if err := client.SendMessage(ctx, toUser, content); err != nil {
		log.Printf("Failed to send message: %v", err)
		return
	}

	s.metrics.mu.Lock()
	s.metrics.messagesExchanged++
	s.metrics.mu.Unlock()
}

func (s *Simulator) simulateReadFeed(ctx context.Context, client *reddit.Client) {
	_, err := client.GetFeed(ctx, 0, 20)
	if err != nil {
		log.Printf("Failed to read feed: %v", err)
	}
}

func (s *Simulator) printMetrics() {
	s.metrics.mu.Lock()
	defer s.metrics.mu.Unlock()

	var totalLatency time.Duration
	for _, lat := range s.metrics.responseLatencies {
		totalLatency += lat
	}
	avgLatency := totalLatency / time.Duration(len(s.metrics.responseLatencies))

	fmt.Printf("\nSimulation Metrics:\n")
	fmt.Printf("Total Posts Created: %d\n", s.metrics.postsCreated)
	fmt.Printf("Total Comments Created: %d\n", s.metrics.commentsCreated)
	fmt.Printf("Total Votes Cast: %d\n", s.metrics.votesCreated)
	fmt.Printf("Total Messages Exchanged: %d\n", s.metrics.messagesExchanged)
	fmt.Printf("Average Response Latency: %v\n", avgLatency)
}

func main() {
	log.SetFlags(log.Ltime | log.Lmicroseconds)
	log.Println("Starting Reddit simulator...")
	sim := NewSimulator(5, "http://localhost:8080")
	ctx := context.Background()
	log.Println("Running simulation...")
	sim.Run(ctx, 2*time.Minute)
}
